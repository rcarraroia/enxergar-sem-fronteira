#!/usr/bin/env node

/**
 * Script de Monitoramento de Qualidade
 *
 * Coleta m√©tricas de qualidade do c√≥digo e gera relat√≥rios:
 * - M√©tricas de ESLint (erros, warnings)
 * - Cobertura de testes
 * - M√©tricas de TypeScript
 * - Tamanho do bundle
 * - Complexidade do c√≥digo
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ============================================================================
// CONFIGURA√á√ïES
// ============================================================================

const CONFIG = {
  outputDir: 'quality-reports',
  thresholds: {
    eslintErrors: 0,
    eslintWarnings: 50,
    testCoverage: 70,
    bundleSize: 2000, // KB
    typeScriptErrors: 0
  },
  colors: {
    success: '\x1b[32m',
    warning: '\x1b[33m',
    error: '\x1b[31m',
    info: '\x1b[36m',
    reset: '\x1b[0m'
  }
};

// ============================================================================
// UTILIT√ÅRIOS
// ============================================================================

function log(message, color = 'reset') {
  console.log(`${CONFIG.colors[color]}${message}${CONFIG.colors.reset}`);
}

function execCommand(command, options = {}) {
  try {
    const result = execSync(command, {
      encoding: 'utf8',
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options
    });
    return { success: true, output: result };
  } catch (error) {
    return {
      success: false,
      output: error.stdout || error.message,
      error: error.stderr || error.message
    };
  }
}

function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

function saveReport(filename, data) {
  ensureDir(CONFIG.outputDir);
  const filepath = path.join(CONFIG.outputDir, filename);
  fs.writeFileSync(filepath, JSON.stringify(data, null, 2));
  return filepath;
}

// ============================================================================
// COLETORES DE M√âTRICAS
// ============================================================================

/**
 * Coleta m√©tricas do ESLint
 */
function collectESLintMetrics() {
  log('üìã Coletando m√©tricas do ESLint...', 'info');

  // Usar formato mais simples para evitar problemas de JSON
  const result = execCommand('npx eslint . --format compact', { silent: true });

  try {
    const output = result.output || result.error || '';
    const lines = output.split('\n').filter(line => line.trim());

    let totalErrors = 0;
    let totalWarnings = 0;
    let filesWithIssues = new Set();

    lines.forEach(line => {
      if (line.includes(': error ')) {
        totalErrors++;
        const filePath = line.split(':')[0];
        if (filePath) filesWithIssues.add(filePath);
      } else if (line.includes(': warning ')) {
        totalWarnings++;
        const filePath = line.split(':')[0];
        if (filePath) filesWithIssues.add(filePath);
      }
    });

    return {
      errors: totalErrors,
      warnings: totalWarnings,
      files: filesWithIssues.size,
      filesWithIssues: filesWithIssues.size
    };
  } catch (error) {
    log(`‚ùå Erro ao processar sa√≠da do ESLint: ${error.message}`, 'error');
    return { errors: -1, warnings: -1, files: 0 };
  }
}

/**
 * Coleta m√©tricas do TypeScript
 */
function collectTypeScriptMetrics() {
  log('üîß Coletando m√©tricas do TypeScript...', 'info');

  const result = execCommand('npx tsc --noEmit --pretty false', { silent: true });

  const errors = result.output ? result.output.split('\n').filter(line =>
    line.includes('error TS') || line.includes('): error')
  ).length : 0;

  return {
    errors,
    hasErrors: !result.success,
    output: result.output
  };
}

/**
 * Coleta m√©tricas de testes
 */
function collectTestMetrics() {
  log('üß™ Coletando m√©tricas de testes...', 'info');

  // Executar testes simples primeiro
  const result = execCommand('npm run test:run', { silent: true });

  try {
    const output = result.output || result.error || '';

    // Extrair estat√≠sticas do output
    let tests = 0;
    let passed = 0;
    let failed = 0;
    let coverage = 0;

    // Procurar por linhas de resumo
    const lines = output.split('\n');

    // Procurar por "Test Files" e "Tests"
    const testFilesLine = lines.find(line => line.includes('Test Files'));
    const testsLine = lines.find(line => line.includes('Tests') && !line.includes('Test Files'));

    if (testFilesLine) {
      const failedMatch = testFilesLine.match(/(\d+) failed/);
      const passedMatch = testFilesLine.match(/(\d+) passed/);
      if (failedMatch || passedMatch) {
        // Temos dados v√°lidos
      }
    }

    if (testsLine) {
      const failedMatch = testsLine.match(/(\d+) failed/);
      const passedMatch = testsLine.match(/(\d+) passed/);

      if (failedMatch) failed = parseInt(failedMatch[1]);
      if (passedMatch) passed = parseInt(passedMatch[1]);
      tests = passed + failed;
    }

    // Tentar ler arquivo de coverage se existir
    const coverageFile = path.join('coverage', 'coverage-summary.json');
    if (fs.existsSync(coverageFile)) {
      try {
        const coverageData = JSON.parse(fs.readFileSync(coverageFile, 'utf8'));
        coverage = coverageData.total?.lines?.pct || 0;
      } catch (e) {
        // Ignorar erro de coverage
      }
    }

    return {
      coverage,
      tests,
      passed,
      failed
    };
  } catch (error) {
    log(`‚ùå Erro ao processar m√©tricas de teste: ${error.message}`, 'error');
    return { coverage: 0, tests: 0, passed: 0, failed: 0 };
  }
}

/**
 * Coleta m√©tricas do bundle
 */
function collectBundleMetrics() {
  log('üì¶ Coletando m√©tricas do bundle...', 'info');

  // Executar build
  const buildResult = execCommand('npm run build', { silent: true });

  if (!buildResult.success) {
    log('‚ùå Erro ao fazer build', 'error');
    return { size: -1, gzipSize: -1, files: 0 };
  }

  try {
    // Verificar tamanho dos arquivos de build
    const distDir = 'dist';
    if (!fs.existsSync(distDir)) {
      return { size: -1, gzipSize: -1 };
    }

    let totalSize = 0;
    const files = fs.readdirSync(path.join(distDir, 'assets'));

    files.forEach(file => {
      if (file.endsWith('.js') || file.endsWith('.css')) {
        const filePath = path.join(distDir, 'assets', file);
        const stats = fs.statSync(filePath);
        totalSize += stats.size;
      }
    });

    return {
      size: Math.round(totalSize / 1024), // KB
      gzipSize: Math.round(totalSize / 1024 * 0.3), // Estimativa
      files: files.length
    };
  } catch (error) {
    log(`‚ùå Erro ao calcular tamanho do bundle: ${error.message}`, 'error');
    return { size: -1, gzipSize: -1 };
  }
}

/**
 * Coleta m√©tricas de complexidade
 */
function collectComplexityMetrics() {
  log('üîç Coletando m√©tricas de complexidade...', 'info');

  try {
    // Contar arquivos e linhas
    const srcDir = 'src';
    let totalFiles = 0;
    let totalLines = 0;
    let totalFunctions = 0;
    let totalComponents = 0;

    function countInDirectory(dir) {
      const items = fs.readdirSync(dir);

      items.forEach(item => {
        const itemPath = path.join(dir, item);
        const stats = fs.statSync(itemPath);

        if (stats.isDirectory()) {
          countInDirectory(itemPath);
        } else if (item.endsWith('.ts') || item.endsWith('.tsx')) {
          totalFiles++;

          const content = fs.readFileSync(itemPath, 'utf8');
          const lines = content.split('\n').length;
          totalLines += lines;

          // Contar fun√ß√µes (aproximado)
          const functionMatches = content.match(/function\s+\w+|const\s+\w+\s*=\s*\(/g);
          totalFunctions += functionMatches ? functionMatches.length : 0;

          // Contar componentes React (aproximado)
          const componentMatches = content.match(/export\s+(default\s+)?function\s+[A-Z]|const\s+[A-Z]\w*\s*=\s*\(/g);
          totalComponents += componentMatches ? componentMatches.length : 0;
        }
      });
    }

    if (fs.existsSync(srcDir)) {
      countInDirectory(srcDir);
    }

    return {
      files: totalFiles,
      lines: totalLines,
      functions: totalFunctions,
      components: totalComponents,
      avgLinesPerFile: totalFiles > 0 ? Math.round(totalLines / totalFiles) : 0
    };
  } catch (error) {
    log(`‚ùå Erro ao calcular complexidade: ${error.message}`, 'error');
    return { files: 0, lines: 0, functions: 0, components: 0, avgLinesPerFile: 0 };
  }
}

// ============================================================================
// AN√ÅLISE E RELAT√ìRIOS
// ============================================================================

/**
 * Analisa m√©tricas e determina status
 */
function analyzeMetrics(metrics) {
  const analysis = {
    overall: 'success',
    issues: [],
    warnings: [],
    recommendations: []
  };

  // An√°lise ESLint
  if (metrics.eslint.errors > CONFIG.thresholds.eslintErrors) {
    analysis.overall = 'error';
    analysis.issues.push(`ESLint: ${metrics.eslint.errors} erros encontrados (limite: ${CONFIG.thresholds.eslintErrors})`);
  }

  if (metrics.eslint.warnings > CONFIG.thresholds.eslintWarnings) {
    analysis.overall = analysis.overall === 'success' ? 'warning' : analysis.overall;
    analysis.warnings.push(`ESLint: ${metrics.eslint.warnings} warnings encontrados (limite: ${CONFIG.thresholds.eslintWarnings})`);
  }

  // An√°lise TypeScript
  if (metrics.typescript.errors > CONFIG.thresholds.typeScriptErrors) {
    analysis.overall = 'error';
    analysis.issues.push(`TypeScript: ${metrics.typescript.errors} erros encontrados`);
  }

  // An√°lise de testes
  if (metrics.tests.coverage < CONFIG.thresholds.testCoverage) {
    analysis.overall = analysis.overall === 'success' ? 'warning' : analysis.overall;
    analysis.warnings.push(`Cobertura de testes: ${metrics.tests.coverage}% (meta: ${CONFIG.thresholds.testCoverage}%)`);
  }

  if (metrics.tests.failed > 0) {
    analysis.overall = 'error';
    analysis.issues.push(`Testes: ${metrics.tests.failed} testes falhando`);
  }

  // An√°lise do bundle
  if (metrics.bundle.size > CONFIG.thresholds.bundleSize) {
    analysis.overall = analysis.overall === 'success' ? 'warning' : analysis.overall;
    analysis.warnings.push(`Bundle: ${metrics.bundle.size}KB (limite: ${CONFIG.thresholds.bundleSize}KB)`);
  }

  // Recomenda√ß√µes
  if (metrics.complexity.avgLinesPerFile > 200) {
    analysis.recommendations.push('Considere quebrar arquivos grandes em m√≥dulos menores');
  }

  if (metrics.eslint.warnings > 20) {
    analysis.recommendations.push('Execute `npm run lint:fix` para corrigir warnings automaticamente');
  }

  if (metrics.tests.coverage < 80) {
    analysis.recommendations.push('Adicione mais testes para melhorar a cobertura');
  }

  return analysis;
}

/**
 * Gera relat√≥rio em formato texto
 */
function generateTextReport(metrics, analysis) {
  const lines = [];

  lines.push('');
  lines.push('üéØ RELAT√ìRIO DE QUALIDADE DO C√ìDIGO');
  lines.push('=====================================');
  lines.push('');

  // Status geral
  const statusIcon = analysis.overall === 'success' ? '‚úÖ' :
                    analysis.overall === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
  lines.push(`Status Geral: ${statusIcon} ${analysis.overall.toUpperCase()}`);
  lines.push('');

  // M√©tricas principais
  lines.push('üìä M√âTRICAS PRINCIPAIS');
  lines.push('----------------------');
  lines.push(`ESLint Erros:      ${metrics.eslint.errors}`);
  lines.push(`ESLint Warnings:   ${metrics.eslint.warnings}`);
  lines.push(`TypeScript Erros:  ${metrics.typescript.errors}`);
  lines.push(`Cobertura Testes:  ${metrics.tests.coverage}%`);
  lines.push(`Testes Passando:   ${metrics.tests.passed}/${metrics.tests.tests}`);
  lines.push(`Bundle Size:       ${metrics.bundle.size}KB`);
  lines.push('');

  // Complexidade
  lines.push('üîç COMPLEXIDADE DO C√ìDIGO');
  lines.push('-------------------------');
  lines.push(`Arquivos:          ${metrics.complexity.files}`);
  lines.push(`Linhas de C√≥digo:  ${metrics.complexity.lines}`);
  lines.push(`Fun√ß√µes:           ${metrics.complexity.functions}`);
  lines.push(`Componentes:       ${metrics.complexity.components}`);
  lines.push(`M√©dia Linhas/Arq:  ${metrics.complexity.avgLinesPerFile}`);
  lines.push('');

  // Issues
  if (analysis.issues.length > 0) {
    lines.push('‚ùå PROBLEMAS CR√çTICOS');
    lines.push('---------------------');
    analysis.issues.forEach(issue => lines.push(`‚Ä¢ ${issue}`));
    lines.push('');
  }

  // Warnings
  if (analysis.warnings.length > 0) {
    lines.push('‚ö†Ô∏è AVISOS');
    lines.push('---------');
    analysis.warnings.forEach(warning => lines.push(`‚Ä¢ ${warning}`));
    lines.push('');
  }

  // Recomenda√ß√µes
  if (analysis.recommendations.length > 0) {
    lines.push('üí° RECOMENDA√á√ïES');
    lines.push('----------------');
    analysis.recommendations.forEach(rec => lines.push(`‚Ä¢ ${rec}`));
    lines.push('');
  }

  lines.push(`Relat√≥rio gerado em: ${new Date().toLocaleString('pt-BR')}`);
  lines.push('');

  return lines.join('\n');
}

// ============================================================================
// FUN√á√ÉO PRINCIPAL
// ============================================================================

async function main() {
  log('üöÄ Iniciando coleta de m√©tricas de qualidade...', 'info');

  const startTime = Date.now();

  // Coletar todas as m√©tricas
  const metrics = {
    timestamp: new Date().toISOString(),
    eslint: collectESLintMetrics(),
    typescript: collectTypeScriptMetrics(),
    tests: collectTestMetrics(),
    bundle: collectBundleMetrics(),
    complexity: collectComplexityMetrics()
  };

  // Analisar m√©tricas
  const analysis = analyzeMetrics(metrics);

  // Gerar relat√≥rios
  const report = {
    metrics,
    analysis,
    duration: Date.now() - startTime
  };

  // Salvar relat√≥rio JSON
  const jsonFile = saveReport(`quality-report-${Date.now()}.json`, report);
  log(`üìÑ Relat√≥rio JSON salvo: ${jsonFile}`, 'success');

  // Salvar relat√≥rio de texto
  const textReport = generateTextReport(metrics, analysis);
  const textFile = path.join(CONFIG.outputDir, 'latest-quality-report.txt');
  fs.writeFileSync(textFile, textReport);
  log(`üìÑ Relat√≥rio de texto salvo: ${textFile}`, 'success');

  // Exibir relat√≥rio no console
  console.log(textReport);

  // Exit code baseado no status
  const exitCode = analysis.overall === 'error' ? 1 : 0;

  log(`‚ú® Coleta conclu√≠da em ${report.duration}ms`, 'success');

  process.exit(exitCode);
}

// Executar se chamado diretamente
if (require.main === module) {
  main().catch(error => {
    log(`üí• Erro fatal: ${error.message}`, 'error');
    console.error(error);
    process.exit(1);
  });
}

module.exports = {
  collectESLintMetrics,
  collectTypeScriptMetrics,
  collectTestMetrics,
  collectBundleMetrics,
  collectComplexityMetrics,
  analyzeMetrics,
  generateTextReport
};
